#!/usr/bin/python
#

# TODO
# read in profiles and add them to NetworkManager
# create GNOME panel applet to show mesh status
# any use for the env vars sent with 'up'?

import ConfigParser
import datetime
import glob
import os
import pyjavaproperties
import re
import sys
import NetworkManager
import random
import socket
import subprocess
import uuid



class ConnectionFileManager():
    '''
    manage the generation of NetworkManager system-connections/ files based on
    the Commotion profiles
    '''

    def __init__(self, f=None):
        if f:
            self.f = f
        else:
            self.f = open('/tmp/nm-dispatcher-olsrd.log', 'ab')

    def _log(self, msg):
        self.f.write(msg + '\n')

    def _ip_string2int(self, s):
        "Convert dotted IPv4 address to integer."
        # first validate the IP
        try:
            socket.inet_aton(s)
        except socket.error:
            self._log('"' + s + '" is not a valid IP address!')
            return
        return reduce(lambda a,b: a<<8 | b, map(int, s.split(".")))

    def _ip_int2string(self, ip):
        "Convert 32-bit integer to dotted IPv4 address."
        return ".".join(map(lambda n: str(ip>>n & 0xFF), [24,16,8,0]))

    def _get_net_size(self, netmask):
        # after bin(), remove the 0b prefix, strip the 0s and count the 1s
        binary_str = bin(self._ip_string2int(netmask))[2:]
        return str(len(binary_str.rstrip('0')))

    def _generate_ip(self, ip, netmask):
        ipint = self._ip_string2int(ip)
        netmaskint = self._ip_string2int(netmask)
        return self._ip_int2string((random.randint(0, 2147483648) & ~netmaskint) + ipint)

    def writeConnections(self, profiles):
        '''write out the Commotion profiles as NetworkManager system-connections/'''

        self._log('\n----------------------------------------')
        self._log('Writing connections:')
        for ssid,profile in profiles.items():
            fn = os.path.join('/etc/NetworkManager/system-connections', ssid)
            myuuid = uuid.uuid4()
            if os.path.exists(fn):
                mtime = os.path.getmtime(fn)
                if not profile['mtime'] > mtime: #and not profile['randomip']:
                    # only update if the profile is newer than the connection
                    self._log('Existing connection "' + fn + '" is newer than profile "'
                              + profile['filename'] + '"')
                    continue
                self._log('Overwriting existing file: ' + fn)
                c = ConfigParser.ConfigParser()
                with open(fn) as f:
                    c.readfp(f)
                myuuid = c.get('connection', 'uuid')
                self._log('Reusing UUID "' + myuuid + '" from "' + fn + '"')
            f = open(fn, 'wb')
            config = ConfigParser.RawConfigParser()
            config.add_section('connection')
            config.set('connection', 'id', ssid)
            config.set('connection', 'uuid', myuuid)
            config.set('connection', 'type', '802-11-wireless')
            config.add_section('802-11-wireless')
            config.set('802-11-wireless', 'ssid', ssid)
            config.set('802-11-wireless', 'mode', 'adhoc')
            config.set('802-11-wireless', 'band', 'bg')
            config.set('802-11-wireless', 'channel', profile['channel'])
            config.set('802-11-wireless', 'bssid', profile['bssid'])
            if 'key-mgmt' in profile:
                config.add_section('802-11-wireless-security')
                config.set('802-11-wireless-security','key-mgmt', profile['key-mgmt'])
                config.set('802-11-wireless-security','auth-alg', 'open')
                config.set('802-11-wireless-security','psk', profile['psk'])
            config.add_section('ipv6')
            config.set('ipv6', 'method', 'auto')
            config.add_section('ipv4')
            config.set('ipv4', 'method', 'manual')
            config.set('ipv4', 'dns', profile['dns'])
            if profile['ipgenerate']:
                ip = self._generate_ip(profile['ip'], profile['netmask'])
                pf = open(os.path.join('/etc/nm-dispatcher-olsrd', ssid + '.profile'), 'r')
                savedsettings = pf.readlines()
                savedsettings.append('ip='ip + '\n')
                pf.close()
                pf = open(os.path.join('/etc/nm-dispatcher-olsrd', ssid + '.profile'), 'w')
                for line in savedsettings:
                    if not 'ipgenerate' in line:
                        if not 'ip=' in line:
                            pf.write(line)
                pf.write('ip=' + ip + '\n')
                pf.write('ipgenerate=false' + '\n')
                pf.close()
            else:
                ip = profile['ip']
            net = self._get_net_size(profile['netmask'])
            config.set('ipv4', 'addresses1', ip + ';' + net + ';0.0.0.0')
            config.write(open(fn, 'w'))
            subprocess.call(['chmod', '600', fn])


class MeshConnection():

    def __init__(self, interface, status):
        self.f = open('/tmp/nm-dispatcher-olsrd.log', 'ab')
        self.log('\n--------------------------------------------------')
        self.log(str(datetime.datetime.now()))
        self.log('launching with "' + interface + '" and "' + status + '"')

        self.interface = interface
        self.olsrdconf = '/etc/olsrd/olsrd.conf'

        self.profiles = self.readProfiles()
        cfm = ConnectionFileManager(self.f)
        cfm.writeConnections(self.profiles)

        if status == 'up':
            self.log('Checking if "' + interface + '" should be a mesh connection')
            meshconnection = self.getMeshConnection(interface)
            if meshconnection:
                self.startOlsrd(meshconnection['profile']['conf'])
        if status == 'down':
            self.stopOlsrd() #If this launches with eth0, and eth0 is being brought down, this logic will kill olsrd, even if a mesh connection is still active


    def log(self, msg):
        self.f.write(msg + '\n')


    def readProfiles(self):
        '''get all the available mesh profiles and return as a dict'''
        profiles = dict()
        self.log('\n----------------------------------------')
        self.log('Reading profiles:')
        for f in glob.glob('/etc/nm-dispatcher-olsrd/*.profile'):
            self.log('reading profile: "' + f + '"')
            p = pyjavaproperties.Properties()
            p.load(open(f))
            profile = dict()
            profile['filename'] = f
            profile['mtime'] = os.path.getmtime(f)
            for k,v in p.items():
                profile[k] = v
            conf = re.sub('(.*)\.profile', r'\1.conf', f)
            if os.path.exists(conf):
                self.log('profile has custom olsrd.conf: "' + conf + '"')
                profile['conf'] = conf
            else:
                self.log('using built in olsrd.conf: "' + self.olsrdconf + '"')
                profile['conf'] = self.olsrdconf
            self.log('adding "' + f + '" as profile "' + p['ssid'] + '"')
            profiles[p['ssid']] = profile
        return profiles


    def readConnections(self):
        '''
        Get all pre-configured wifi connections from NetworkManager and return dict'''
        connections = dict()
        for c in NetworkManager.Settings.ListConnections():
            settings = c.GetSettings()
            if settings['connection']['type'] == '802-11-wireless':
                k = settings['connection']['id']
                self.log('found Connection "' + k + '"')
                connections[k] = settings
        return connections


    def matchProfile(self, ssid):
        ret = False
        for k,v in self.profiles.items():
            if k == ssid and v['ssid'] == ssid:
                self.log('SSID "' + ssid + '" matches, we have a mesh profile!')
                return v


    def getMeshConnection(self, interface):
        '''
        match the active adhoc connection with the mesh profiles, and if there
        is a match, return the connection dict
        '''
        c = self.getAdhocConnection(interface)
        if c:
            ssid = c['wireless']['ssid']
            self.log('checking if SSID "' + ssid + '" matches one of our profiles')
            profile = self.matchProfile(ssid)
            if profile:
                c['profile'] = profile
                return c


    def getAdhocConnection(self, interface):
        '''
        return data about the active adhoc connection for a given interface
        '''
        connection = None

        # first find the active connection that we are interested in
        foundit = False
        for ac in NetworkManager.NetworkManager.ActiveConnections:
            for d in ac.Devices:
                wireless = None
                ap = None
                if d.Managed and d.Interface == interface \
                        and d.DeviceType == NetworkManager.NM_DEVICE_TYPE_WIFI:
                    wireless = d.SpecificDevice()
                    if wireless.Mode == NetworkManager.NM_802_11_MODE_ADHOC:
                        ap = wireless.ActiveAccessPoint
                        foundit = True
                        break
            if foundit:
                break
            ac = None
        if ac == None:
            return None

        # then find the settings for that active connection
        settings = ac.Connection.GetSettings()
        if settings and ap \
                and settings['connection']['type'] == '802-11-wireless' \
                and ap.Ssid == settings['802-11-wireless']['ssid']:
            w = dict()
            w['mac-address'] = wireless.HwAddress
            w['bitrate'] = wireless.Bitrate
            w['ssid'] = ap.Ssid
            w['bssid'] = ap.HwAddress
            w['channel'] = (ap.Frequency - 2407) / 5
            w['maxbitrate'] = ap.MaxBitrate
            w['strength'] = ap.Strength
            self.log('Found mesh adhoc connection: ' + w['ssid'] + '/'
                     + w['bssid'] + '/' + str(w['channel']))
            connection = settings
            connection['wireless'] = w

        return connection


    def startOlsrd(self, conf):
        '''start the olsrd daemon'''
        self.log('start olsrd: ')
        cmd = ['/usr/sbin/olsrd', '-i', self.interface, '-f', conf]
        self.log(" ".join([x for x in cmd]))
        p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        out, err = p.communicate()
        if out:
            self.log('stdout: ' + out)
        if err:
            self.log('stderr: ' + err)


    def stopOlsrd(self):
        '''stop the olsrd daemon'''
        self.log('stop olsrd')
        cmd = ['/usr/bin/killall', '-v', 'olsrd']
        self.log(" ".join([x for x in cmd]))
        p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        out, err = p.communicate()
        if out:
            self.log('stdout: ' + out)
        if err:
            self.log('stderr: ' + err)


interface = sys.argv[1]
status = sys.argv[2]
m = MeshConnection(interface, status)
